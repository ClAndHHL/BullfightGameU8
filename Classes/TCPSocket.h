/*
 * define file about portable socket class.
 * description:this sock is suit both windows and linux
 * design:odison
 * e-mail:odison@126.com>
 *
 */

#ifndef _ODSOCKET_H_
#define _ODSOCKET_H_

#ifdef WIN32
#include <winsock2.h>
typedef int				socklen_t;
#else
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <arpa/inet.h>
typedef int				SOCKET;

//#pragma region define win32 const variable in linux
#define INVALID_SOCKET	-1
#define SOCKET_ERROR	-1
//#pragma endregion
#endif

//长度定义
#define SOCKET_TCP_BUFFER			16384								//网络缓冲
#define SOCKET_TCP_PACKET			(SOCKET_TCP_BUFFER-sizeof(TCP_Head))//网络缓冲

class TCPSocket {
    
public:
    TCPSocket(SOCKET sock = INVALID_SOCKET);
    ~TCPSocket();
    
    // Create socket object for snd/recv data
    bool Create(int af, int type, int protocol = 0);
    
    // Connect socket
    bool Connect(const char* ip, unsigned short port);
    //#region server
    // Bind socket
    bool Bind(unsigned short port);
    
    // Listen socket
    bool Listen(int backlog = 5);
    
    // Accept socket
    bool Accept(TCPSocket& s, char* fromip = NULL);
    //#endregion
    int Select();
    // Send socket
    int Send(const char* buf, int len, int flags = 0);
    
    // Recv socket
    int Recv(char* buf, int len, int flags = 0);
    
    // Close socket
    int Close();
    
    // Get errno
    int GetError();
    
    //#pragma region just for win32
    // Init winsock DLL
    static int Init();
    // Clean winsock DLL
    static int Clean();
    //#pragma endregion
    
    // Domain parse
    static bool DnsParse(const char* domain, char* ip);
    
    TCPSocket& operator = (SOCKET s);
    
    operator SOCKET ();
    
protected:
    SOCKET m_sock;
    fd_set  fdR;

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
	//接收变量
protected:
	WORD							m_wRecvSize;						//接收长度
	BYTE							m_cbRecvBuf[SOCKET_TCP_BUFFER * 10];		//接收缓冲
	//加密数据
protected:
	BYTE							m_cbSendRound;						//字节映射
	BYTE							m_cbRecvRound;						//字节映射
	DWORD							m_dwSendXorKey;						//发送密钥
	DWORD							m_dwRecvXorKey;						//接收密钥

	BYTE static						g_SendByteMap[];
	BYTE static						g_RecvByteMap[];
	//计数变量
protected:
	DWORD							m_dwSendTickCount;					//发送时间
	DWORD							m_dwRecvTickCount;					//接收时间
	DWORD							m_dwSendPacketCount;				//发送计数
	DWORD							m_dwRecvPacketCount;				//接受计数

	//加密函数
protected:
	//解密数据
	WORD CrevasseBuffer(BYTE cbDataBuffer[], WORD wDataSize);
	//加密数据
	WORD EncryptBuffer(BYTE cbDataBuffer[], WORD wDataSize, WORD wBufferSize);

	//内联函数
private:
	//字节映射
	inline WORD SeedRandMap(WORD wSeed);
	//发送映射
	inline BYTE MapSendByte(BYTE cbData);
	//接收映射
	inline BYTE MapRecvByte(BYTE cbData);

	//操作接口
public:
	//发送函数
	virtual DWORD __cdecl SendData(WORD wMainCmdID, WORD wSubCmdID);
	//发送函数
	virtual DWORD __cdecl SendData(WORD wMainCmdID, WORD wSubCmdID, VOID * const pData, WORD wDataSize);

	//辅助函数
protected:
	//关闭连接
	//VOID CloseSocket(BYTE cbShutReason);
	//缓冲数据
	//VOID AmortizeBuffer(VOID * pData, WORD wDataSize);
	//发送数据
	DWORD SendDataBuffer(VOID * pBuffer, WORD wSendSize);

	//消息函数
public:
	//网络读取
	LRESULT OnSocketNotifyRead(WPARAM wParam, LPARAM lParam);
};


#endif
